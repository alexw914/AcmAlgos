//
// Created by Krisw on 2025/12/8.
//

/*
竖直四子棋的棋盘是竖立起来的，双方轮流选择棋盘的一列下子，棋子因重力落到棋盘底部或者其他棋子之上，当一列的棋子放满时，无法再在这列上下子。

一方的4个棋子横、竖或者斜方向连成一线时获胜。

现给定一个棋盘和红蓝对弈双方的下子步骤，判断红方或蓝方是否在某一步获胜。

下面以一个6×5的棋盘图示说明落子过程：

输入描述

输入为2行，第一行指定棋盘的宽和高，为空格分隔的两个数字；

第二行依次间隔指定红蓝双方的落子步骤，第1步为红方的落子，第2步为蓝方的落子，第3步为红方的落子，以此类推。

步骤由空格分隔的一组数字表示，每个数字为落子的列的编号（最左边的列编号为1，往右递增）。用例保证数字均为32位有符号数。

输出描述

如果落子过程中红方获胜，输出 N,red ；

如果落子过程中蓝方获胜，输出 N,blue ；

如果出现非法的落子步骤，输出 N,error。

N为落子步骤的序号，从1开始。如果双方都没有获胜，输出 0,draw 。

非法落子步骤有两种，一是列的编号超过棋盘范围，二是在一个已经落满子的列上落子。

N和单词red、blue、draw、error之间是英文逗号连接。

示例1   输入输出示例仅供调试，后台判题数据一般不包含示例

输入

5 5
1 1 2 2 3 3 4 4

输出

7,red

说明

在第7步，红方在第4列落下一子后，红方的四个子在第一行连成一线，故红方获胜，输出 7,red。

示例2  输入输出示例仅供调试，后台判题数据一般不包含示例

输入

5 5
0 1 2 2 3 3 4 4

输出

1,error

说明

第1步的列序号为0，超出有效列编号的范围，故输出 1,error。

 */

#include <bits/stdc++.h>
using namespace std;




int main() {
    int m, n;
    cin >> n >> m;
    vector<vector<char>> maze(m, vector<char>(n));
    std::string line;
    if (cin >> line) {

        
    }





    return 0;
}
