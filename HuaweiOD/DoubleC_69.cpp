//
// Created by Krisw on 2025/12/28.
//

/*
有一套系统需升级，为减小系统升级期间的影响，需根据系统过去一段时间内的每小时平均访问数据，来预测最佳升级时间窗。

现给长度为168（7*24）的整数数组，表示一个周期（假设从周一00:00到周日24:00）的每小时历史数据，最佳升级时间窗选择规则如下：

1：时间窗内累计用户访问量必须大于给定的容忍值。

2：时间窗必须是连续的x个小时，最大的x即为最佳升级时间窗，且不超过7*24.

3：时间窗允许跨周期，例如当前周期的第167小时到下一周期的第166小时，是一个长度为168的时间窗。

请计算最佳升级时间窗，并返回其开始时间和结束时间的数组下标。如果存在多个最佳升级时间窗，返回开始时间下标最小的一个。

输入

第一行为整数n，表示给定的升级影响的容忍值，取值范围：[0, 2^31]。

第二行为7*24个整数，表示一个周期（7*24）的每个小时用户访问量，每个值的范围：[0, 2^31]。

输出

两个整数，分别表示所计算出的最佳升级时间窗的开始时间下标（包含）和结束时间下标（包含），不存在时返回 -1 -1 。

示例1：

输入

6
1 2 3 4 5 6 7 8 9 10 11 12 12 11 10 9 8 7 6 5 4 3 2 1 1 2 3 4 5 6 7 8 9 10 11 12 12 11 10 9 8 7 6 5 4 3 2 1 1 2 3 4 5 6 7 8 9 10 11 12 12 11 10 9 8 7 6 5 4 3 2 1 1 2 3 4 5 6 7 8 9 10 11 12 12 11 10 9 8 7 6 5 4 3 2 1 1 2 3 4 5 6 7 8 9 10 11 12 12 11 10 9 8 7 6 5 4 3 2 1 1 2 3 4 5 6 7 8 9 10 11 12 12 11 10 9 8 7 6 5 4 3 2 1 1 2 3 4 5 6 7 8 9 10 11 12 12 11 10 9 8 7 6 5 4 3 2 1


输出

22 25

说明

最佳升级窗口为：2 1 1 2
*/

#include <iostream>
#include <vector>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;

    vector<int> visitNum(168, 0);
    for (int i = 0; i < 168; i++) { cin >> visitNum[i]; }

    int bestStart = -1;
    int bestEnd = -1;
    int bestLen = 0; // 当前找到的最大时间窗长度
    // 枚举每一个作为起点的小时
    for (int s = 0; s < 168; ++s) {
        long long sum = 0;
        int len = 0;

        // 最多扩展 168 小时（绕一圈）
        while (len < 168) {
            int idx = (s + len) % 168; // 环形数组
            if (sum + visitNum[idx] > n) {
                break;
            }
            sum += visitNum[idx];
            ++len;
        }

        if (len > 0) {
            if (len > bestLen) {
                bestLen = len;
                bestStart = s;
                bestEnd = (s + len - 1) % 168;
            } else if (len == bestLen && len > 0) {
                // 同样长度，起点更小的优先
                if (bestStart == -1 || s < bestStart) {
                    bestStart = s;
                    bestEnd = (s + len - 1) % 168;
                }
            }
        }
    }

    if (bestLen == 0) {
        cout << -1 << " " << -1 << "\n";
    } else {
        cout << bestStart << " " << bestEnd << "\n";
    }

    return 0;
}
