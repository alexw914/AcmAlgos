//
// Created by Krisw on 2025/12/21.
//
/*
现在有一队小朋友，他们高矮不同，，我们以正整数数组表示这一队小朋友的身高，如数组{5,3,1,2,3}。
我们现在希望小朋友排队，以“高”“矮”“高”“矮”顺序排列，每一个“高”位置的小朋友要比相邻的位置高或者相等；
每一个“矮”位置的小朋友要比相邻的位置矮或者相等；要求小朋友们移动的距离和最小，第一个从“高”位开始排，输出最小移动距离即可。
移动距离的定义如下所示：第二位小朋友移到第三位小朋友后面，移动距离为1，若移动到第四位小朋友后面，移动距离为2。
输入描述：

排序前的小朋友，以英文空格的正整数：4 3 5 7 8
小朋友<100个
输出描述：

排序后的小朋友，以英文空格分割的正整数：4 3 7 5 8
输出结果为最小移动距离，只有5和7交换了位置，移动距离都是1
示例：

输入：

4 1 3 5 2
输出：

4 1 5 2 3
输入：

1 1 1 1 1
输出：

1 1 1 1 1
说明：

相邻位置可以相等
输入：

xxx
输出：

[]
说明：

出现非法参数情况，返回空数组
*/

#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    vector<long long> a;
    long long x;

    // 正常输入：从标准输入读所有整数（支持一行或多行）
    while (cin >> x) a.push_back(x);

    int n = (int)a.size();
    long long moves = 0;

    for (int i = 0; i < n - 1; i++) {
        if (i % 2 == 0) {
            // 高位：a[i] >= a[i+1]
            if (a[i] < a[i + 1]) {
                swap(a[i], a[i + 1]);
                moves++;
            }
        } else {
            // 矮位：a[i] <= a[i+1]
            if (a[i] > a[i + 1]) {
                swap(a[i], a[i + 1]);
                moves++;
            }
        }
    }

    // 输出调整后的队列
    for (int i = 0; i < n; i++) {
        if (i) cout << ' ';
        cout << a[i];
    }
    cout << "\n";

    // 输出最小移动距离
    cout << moves << "\n";

    return 0;
}
