//
// Created by Krisw on 2026/1/9.
//

/*
小明在玩一个积木消消乐的游戏。桌面上放着 n 堆积木，每堆积木的数量不尽相同。小明拥有一种特殊的“减半魔法”，魔法的使用规则如下：
每次施放魔法时，小明可以指定一个当前桌面上存在的积木数量 V。
施放魔法后，桌面上所有数量为 V 的积木堆，其数量都会瞬间变为原来的一半（向下取整，即 V' = floor (V/2)r。
当某堆积木的数量变为 0 时，该堆积木被视为“收完”。
小明希望使用最少的魔法次数将所有的积木堆全部收完。请你帮他计算出这个最少次数。
输入描述
第一行输入一个正整数 n，表示积木的堆数（1 < n < 10^5）。
第二行输入 n 个正整数，表示每堆积木的初始个数，数值之间用空格分隔（每个数值范围 [1, 10^9]）。
输出描述
输出一个整数，表示收完所有积木堆所需的最少魔法次数。
示例 1
输入：
4

4 4 4 4
输出：
3
说明：
初始状态：[4, 4, 4, 4]。
第一次魔法：指定 V=4。所有堆变为 4//2=2。状态变为 [2, 2, 2, 2]。
第二次魔法：指定 V=2。所有堆变为 2//2=1。状态变为 [1, 1, 1, 1]。
第三次魔法：指定 V=1。所有堆变为 1//2=0。状态变为 [0, 0, 0, 0]。
共需 3 次。


示例 2
输入：
2

3 4
输出：
4
说明：
初始状态：[3, 4]。
无论先选 3 还是先选 4，为了使所有积木最终变 0，过程中出现的每一个不同的非零数量都必须作为一次魔法的目标。
4 变化过程：4 -> 2 -> 1 -> 0。
3 变化过程：3 -> 1 -> 0。
整个过程中出现的不同非零数量集合为 {4, 3, 2, 1}。因此最少需要 4 次魔法。
*/

#include <iostream>
#include <unordered_set>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;

    unordered_set<int> s;
    s.reserve(static_cast<size_t>(n) * 32);
    s.max_load_factor(0.7);

    for (int i = 0; i < n; ++i) {
        int x;
        cin >> x;
        while (x > 0) {
            s.insert(x);
            x >>= 1;
        }
    }

    cout << s.size() << "\n";
    return 0;
}
